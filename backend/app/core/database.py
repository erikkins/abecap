"""
Database configuration and connection
"""

import uuid
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy import Column, Integer, String, Float, DateTime, Boolean, ForeignKey, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from datetime import datetime, timedelta

from app.core.config import settings


# Convert sync URL to async
DATABASE_URL = settings.DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://")

# Connection pool settings with timeout to fail fast if DB unavailable
engine = create_async_engine(
    DATABASE_URL,
    echo=settings.DEBUG,
    pool_pre_ping=True,
    pool_size=5,
    max_overflow=10,
    pool_timeout=3,  # 3 second timeout for getting connection from pool
    connect_args={
        "command_timeout": 5,  # 5 second query timeout
        "timeout": 3,  # 3 second connection timeout (asyncpg)
    }
)
async_session = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)


class Base(DeclarativeBase):
    pass


# Models
class StockData(Base):
    """Historical stock price data"""
    __tablename__ = "stock_data"
    
    id = Column(Integer, primary_key=True)
    symbol = Column(String(10), index=True, nullable=False)
    date = Column(DateTime, index=True, nullable=False)
    open = Column(Float)
    high = Column(Float)
    low = Column(Float)
    close = Column(Float, nullable=False)
    volume = Column(Float)
    dwap = Column(Float)
    ma_50 = Column(Float)
    ma_200 = Column(Float)
    created_at = Column(DateTime, default=datetime.utcnow)


class Signal(Base):
    """Trading signals generated by scanner"""
    __tablename__ = "signals"
    
    id = Column(Integer, primary_key=True)
    symbol = Column(String(10), index=True, nullable=False)
    signal_type = Column(String(10), nullable=False)  # BUY, SELL
    price = Column(Float, nullable=False)
    dwap = Column(Float)
    pct_above_dwap = Column(Float)
    volume = Column(Float)
    volume_ratio = Column(Float)
    stop_loss = Column(Float)
    profit_target = Column(Float)
    is_strong = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    expires_at = Column(DateTime)
    status = Column(String(20), default="active")  # active, executed, expired


class Position(Base):
    """Open trading positions"""
    __tablename__ = "positions"
    
    id = Column(Integer, primary_key=True)
    symbol = Column(String(10), index=True, nullable=False)
    entry_date = Column(DateTime, nullable=False)
    entry_price = Column(Float, nullable=False)
    shares = Column(Float, nullable=False)
    stop_loss = Column(Float)
    profit_target = Column(Float)
    highest_price = Column(Float)
    signal_id = Column(Integer, ForeignKey("signals.id"))
    status = Column(String(20), default="open")  # open, closed
    created_at = Column(DateTime, default=datetime.utcnow)
    
    trades = relationship("Trade", back_populates="position")


class Trade(Base):
    """Completed trades"""
    __tablename__ = "trades"
    
    id = Column(Integer, primary_key=True)
    position_id = Column(Integer, ForeignKey("positions.id"))
    symbol = Column(String(10), index=True, nullable=False)
    entry_date = Column(DateTime, nullable=False)
    entry_price = Column(Float, nullable=False)
    exit_date = Column(DateTime, nullable=False)
    exit_price = Column(Float, nullable=False)
    shares = Column(Float, nullable=False)
    pnl = Column(Float)
    pnl_pct = Column(Float)
    exit_reason = Column(String(50))
    created_at = Column(DateTime, default=datetime.utcnow)
    
    position = relationship("Position", back_populates="trades")


class BacktestResult(Base):
    """Backtest run results"""
    __tablename__ = "backtest_results"

    id = Column(Integer, primary_key=True)
    name = Column(String(100))
    start_date = Column(DateTime)
    end_date = Column(DateTime)
    initial_capital = Column(Float)
    final_capital = Column(Float)
    total_return_pct = Column(Float)
    annual_return_pct = Column(Float)
    max_drawdown_pct = Column(Float)
    sharpe_ratio = Column(Float)
    win_rate = Column(Float)
    total_trades = Column(Integer)
    config = Column(Text)  # JSON string of config
    created_at = Column(DateTime, default=datetime.utcnow)


class StrategyDefinition(Base):
    """Trading strategy definitions"""
    __tablename__ = "strategy_definitions"

    id = Column(Integer, primary_key=True)
    name = Column(String(100), nullable=False, unique=True)
    description = Column(Text, nullable=True)
    strategy_type = Column(String(50), nullable=False)  # "dwap", "momentum"
    parameters = Column(Text, nullable=False)  # JSON string
    is_active = Column(Boolean, default=False, index=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, onupdate=datetime.utcnow)
    activated_at = Column(DateTime, nullable=True)
    source = Column(String(50), default="manual")  # "manual", "ai_generated"
    is_custom = Column(Boolean, default=False)

    evaluations = relationship("StrategyEvaluation", back_populates="strategy")


class StrategyEvaluation(Base):
    """Strategy backtest evaluation results"""
    __tablename__ = "strategy_evaluations"

    id = Column(Integer, primary_key=True)
    strategy_id = Column(Integer, ForeignKey("strategy_definitions.id"))
    evaluation_date = Column(DateTime, default=datetime.utcnow)
    lookback_days = Column(Integer, default=90)  # 3-month rolling window

    # Performance metrics
    total_return_pct = Column(Float)
    sharpe_ratio = Column(Float)
    max_drawdown_pct = Column(Float)
    win_rate = Column(Float)
    total_trades = Column(Integer)

    # AI recommendation
    recommendation_score = Column(Float)  # 0-100
    recommendation_notes = Column(Text)

    strategy = relationship("StrategyDefinition", back_populates="evaluations")


class AutoSwitchConfig(Base):
    """Configuration for automated strategy switching"""
    __tablename__ = "auto_switch_config"

    id = Column(Integer, primary_key=True)
    is_enabled = Column(Boolean, default=False)
    analysis_frequency = Column(String(20), default="biweekly")  # weekly/biweekly/monthly
    min_score_diff_to_switch = Column(Float, default=10.0)
    min_days_since_last_switch = Column(Integer, default=14)
    notify_on_analysis = Column(Boolean, default=True)
    notify_on_switch = Column(Boolean, default=True)
    admin_email = Column(String(255))
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, onupdate=datetime.utcnow)


class StrategySwitchHistory(Base):
    """Audit log of all strategy switches"""
    __tablename__ = "strategy_switch_history"

    id = Column(Integer, primary_key=True)
    switch_date = Column(DateTime, default=datetime.utcnow, index=True)
    from_strategy_id = Column(Integer, ForeignKey("strategy_definitions.id"), nullable=True)
    to_strategy_id = Column(Integer, ForeignKey("strategy_definitions.id"), nullable=False)
    trigger = Column(String(50), nullable=False)  # "manual", "auto_scheduled"
    reason = Column(Text)
    score_before = Column(Float)
    score_after = Column(Float)

    from_strategy = relationship("StrategyDefinition", foreign_keys=[from_strategy_id])
    to_strategy = relationship("StrategyDefinition", foreign_keys=[to_strategy_id])


class WalkForwardSimulation(Base):
    """Walk-forward analysis simulation results"""
    __tablename__ = "walk_forward_simulations"

    id = Column(Integer, primary_key=True)
    simulation_date = Column(DateTime, default=datetime.utcnow, index=True)
    start_date = Column(DateTime, nullable=False)
    end_date = Column(DateTime, nullable=False)
    reoptimization_frequency = Column(String(20), nullable=False)  # weekly/biweekly/monthly
    total_return_pct = Column(Float)
    sharpe_ratio = Column(Float)
    max_drawdown_pct = Column(Float)
    num_strategy_switches = Column(Integer)
    benchmark_return_pct = Column(Float)
    switch_history_json = Column(Text)  # JSON array of switch events
    equity_curve_json = Column(Text)  # JSON array of equity points
    errors_json = Column(Text)  # JSON array of period debug info
    status = Column(String(20), default="completed")  # pending/completed/failed
    is_daily_cache = Column(Boolean, default=False, index=True)  # For dashboard cached results


class StrategyGenerationRun(Base):
    """Track AI-generated strategy optimization runs"""
    __tablename__ = "strategy_generation_runs"

    id = Column(Integer, primary_key=True)
    run_date = Column(DateTime, default=datetime.utcnow, index=True)
    lookback_weeks = Column(Integer, nullable=False)
    strategy_type = Column(String(50), nullable=False)
    optimization_metric = Column(String(50), nullable=False)  # sharpe/return/calmar
    market_regime_detected = Column(String(50))  # bull/bear/neutral
    best_params_json = Column(Text)  # JSON of best parameters found
    expected_sharpe = Column(Float)
    expected_return_pct = Column(Float)
    expected_drawdown_pct = Column(Float)
    combinations_tested = Column(Integer)
    status = Column(String(20), default="pending")  # pending/completed/failed
    created_strategy_id = Column(Integer, ForeignKey("strategy_definitions.id"), nullable=True)

    created_strategy = relationship("StrategyDefinition")


class User(Base):
    """User account for authentication and subscription management"""
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=True)  # Null for OAuth users
    name = Column(String(255), nullable=True)
    role = Column(String(20), default="user")  # "admin" or "user"
    is_active = Column(Boolean, default=True)

    # OAuth identifiers
    google_id = Column(String(255), nullable=True, unique=True)
    apple_id = Column(String(255), nullable=True, unique=True)

    # Stripe customer ID
    stripe_customer_id = Column(String(255), nullable=True, unique=True)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    # Relationships
    subscription = relationship("Subscription", back_populates="user", uselist=False)

    def is_admin(self) -> bool:
        """Check if user has admin privileges."""
        return self.role == "admin" and self.email == "erik@rigacap.com"

    def to_dict(self, include_subscription: bool = False) -> dict:
        """Convert user to dictionary for API responses.

        Note: Don't access self.subscription here as it triggers lazy loading
        which doesn't work with async SQLAlchemy. The subscription is loaded
        separately in the auth endpoints and added to the response.
        """
        result = {
            "id": str(self.id),
            "email": self.email,
            "name": self.name,
            "role": self.role,
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "last_login": self.last_login.isoformat() if self.last_login else None,
        }
        return result


class Subscription(Base):
    """User subscription for trial and payment management"""
    __tablename__ = "subscriptions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, unique=True)

    # Status: trial, active, canceled, expired, past_due
    status = Column(String(20), default="trial")

    # Trial tracking (no card required)
    trial_start = Column(DateTime, default=datetime.utcnow)
    trial_end = Column(DateTime)

    # Stripe subscription (after trial converts)
    stripe_subscription_id = Column(String(255), nullable=True)
    stripe_price_id = Column(String(255), nullable=True)

    # Billing periods
    current_period_start = Column(DateTime, nullable=True)
    current_period_end = Column(DateTime, nullable=True)
    cancel_at_period_end = Column(Boolean, default=False)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, onupdate=datetime.utcnow)

    # Relationships
    user = relationship("User", back_populates="subscription")

    @classmethod
    def create_trial(cls, user_id) -> "Subscription":
        """Create a new trial subscription."""
        now = datetime.utcnow()
        return cls(
            user_id=user_id,
            status="trial",
            trial_start=now,
            trial_end=now + timedelta(days=7),
        )

    def is_valid(self) -> bool:
        """Check if subscription is currently valid (trial or active)."""
        now = datetime.utcnow()

        if self.status == "trial":
            return self.trial_end and now < self.trial_end

        if self.status == "active":
            if self.current_period_end:
                return now < self.current_period_end
            return True

        return False

    def days_remaining(self) -> int:
        """Get days remaining in trial or current period."""
        now = datetime.utcnow()

        if self.status == "trial" and self.trial_end:
            delta = self.trial_end - now
            return max(0, delta.days)

        if self.status == "active" and self.current_period_end:
            delta = self.current_period_end - now
            return max(0, delta.days)

        return 0

    def to_dict(self) -> dict:
        """Convert subscription to dictionary for API responses."""
        return {
            "id": str(self.id),
            "status": self.status,
            "is_valid": self.is_valid(),
            "days_remaining": self.days_remaining(),
            "trial_start": self.trial_start.isoformat() if self.trial_start else None,
            "trial_end": self.trial_end.isoformat() if self.trial_end else None,
            "current_period_start": self.current_period_start.isoformat() if self.current_period_start else None,
            "current_period_end": self.current_period_end.isoformat() if self.current_period_end else None,
            "cancel_at_period_end": self.cancel_at_period_end,
        }


# Track database availability (set during init_db)
db_available = False
db_init_attempted = False


async def _run_schema_migrations(conn):
    """Run schema migrations for columns that don't exist yet."""
    from sqlalchemy import text

    # Migration: Add is_daily_cache column to walk_forward_simulations
    try:
        await conn.execute(text("""
            ALTER TABLE walk_forward_simulations
            ADD COLUMN IF NOT EXISTS is_daily_cache BOOLEAN DEFAULT FALSE
        """))
        print("✅ Schema migration: is_daily_cache column ready")
    except Exception as e:
        # Column might already exist or table doesn't exist yet
        print(f"⚠️ Schema migration skipped: {e}")

    # Migration: Add errors_json column to walk_forward_simulations
    try:
        await conn.execute(text("""
            ALTER TABLE walk_forward_simulations
            ADD COLUMN IF NOT EXISTS errors_json TEXT
        """))
        print("✅ Schema migration: errors_json column ready")
    except Exception as e:
        print(f"⚠️ Schema migration skipped: {e}")


async def init_db():
    """Initialize database tables"""
    global db_available, db_init_attempted
    db_init_attempted = True

    try:
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
            # Run any pending schema migrations
            await _run_schema_migrations(conn)
        db_available = True
        print("✅ Database initialized")
    except Exception as e:
        print(f"⚠️ Database init failed: {e}")
        db_available = False
        raise


async def get_db():
    """Dependency for getting database session - with lazy initialization"""
    from fastapi import HTTPException, status
    global db_available, db_init_attempted

    # Lazy initialization: try to init DB on first request if not done during startup
    if not db_init_attempted:
        try:
            await init_db()
        except Exception as e:
            print(f"⚠️ Lazy DB init failed: {e}")

    if not db_available:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Database not available. Running in memory-only mode."
        )

    async with async_session() as session:
        yield session
